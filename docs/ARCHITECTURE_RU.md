# Обзор архитектуры

## Проектирование системы

Анализатор производительности солнечных данных построен на **реактивной, неблокирующей архитектуре**, оптимизированной для ультра-высокопроизводительной обработки данных в реальном времени.

### Основные компоненты

```
┌─────────────────────────────────────────────────────────────┐
│                    Слой приложения                           │
│                  (SolarAnalyzerApp)                          │
└────────────────────┬────────────────────────────────────────┘
                     │
        ┌────────────┴────────────┐
        │                         │
┌───────▼────────┐      ┌────────▼──────────┐
│  Визуализация  │      │  Конвейер данных  │
│   (JavaFX)     │      │   (Reactor)       │
└────────────────┘      └────────┬──────────┘
                                 │
                    ┌────────────┴────────────┐
                    │                         │
          ┌─────────▼────────┐    ┌──────────▼─────────┐
          │  Сетевой слой    │    │  Слой обработки    │
          │    (Netty)       │    │  (GPU/CPU)         │
          └──────────────────┘    └────────────────────┘
```

### 1. Сетевой слой (Netty)

**Назначение**: Высокопроизводительный HTTP-клиент для загрузки изображений

**Ключевые возможности**:
- Пул соединений (максимум 10 соединений)
- Выделение прямых байтовых буферов (zero-copy)
- Адаптивное изменение размера буфера приема
- Автоматический retry с резервными URL
- TCP оптимизация (TCP_NODELAY, SO_KEEPALIVE)

**Производительность**:
- Задержка: <50мс для изображений 1МБ
- Пропускная способность: 100+ запросов/сек
- Память: Прямые буферы, минимальное давление на GC

### 2. Реактивный конвейер (Project Reactor)

**Назначение**: Оркестрация неблокирующего потока данных

**Ключевые возможности**:
- Потоковая передача на основе Flux (интервалы 5 секунд)
- Параллельная обработка GPU/CPU
- Автоматическое восстановление после ошибок
- Обработка противодавления
- Совместное использование горячих observable

**Поток**:
```
Загрузка → Обработка (GPU + CPU) → Метрики → Визуализация
   ↓            ↓                      ↓           ↓
Retry      Zero-copy буферы       Lock-free   60+ FPS
```

### 3. Слой обработки

#### GPU обработка (CUDA через JavaCPP)

**Алгоритм**:
1. Декодирование JPEG в Mat (OpenCV)
2. Преобразование в оттенки серого
3. Размытие по Гауссу (σ=1.5)
4. Обнаружение границ Кэнни (50, 150)
5. Кодирование обратно в JPEG

**Производительность**:
- Задержка: 8.5мс в среднем
- Пропускная способность: 117 fps
- Память: GPU VRAM (минимальная память хоста)

#### CPU обработка (SIMD Vector API)

**Алгоритм**:
1. Декодирование JPEG в BufferedImage
2. Оператор Собеля для градиентов
3. Вычисление величины границ
4. Кодирование обратно в JPEG

**Производительность**:
- Задержка: 520мс в среднем
- Пропускная способность: 1.9 fps
- Память: Выделение в куче

### 4. Слой визуализации (JavaFX)

**Назначение**: Дашборд в реальном времени с метриками производительности

**Компоненты**:
- Двойные представления изображений (GPU vs CPU)
- График производительности (задержка во времени)
- Живые метрики (FPS, пропускная способность, ускорение)
- Визуализация тепловой карты

**Производительность**:
- Рендеринг: 60+ FPS
- Частота обновления: 5 секунд
- Память: Буферы изображений вне кучи

### 5. Сбор метрик

**Lock-Free дизайн**:
- LongAdder для счетчиков (без конкуренции)
- AtomicLong для отслеживания min/max
- Нулевые накладные расходы на синхронизацию

**Метрики**:
- Статистика загрузки
- Задержка обработки (GPU/CPU)
- Пропускная способность (кадры/сек)
- Использование памяти
- Коэффициент ускорения

## Поток данных

### Успешный путь

```
1. Таймер срабатывает (каждые 5с)
2. Netty загружает изображение → ByteBuf
3. Reactor разделяет на параллельную обработку:
   a. GPU: ByteBuf → CUDA → обработанные байты
   b. CPU: ByteBuf → SIMD → обработанные байты
4. Результаты объединяются → ProcessedImage
5. Метрики обновляются (lock-free)
6. JavaFX отображает изображения + графики
7. ByteBuf освобождается (подсчет ссылок)
```

### Обработка ошибок

```
Сбой загрузки → Повтор основного URL
              → Попытка резервного URL
              → Логирование ошибки, продолжение

Сбой GPU → Fallback на CPU
        → Логирование предупреждения
        → Продолжение обработки

Таймаут обработки → Пропуск кадра
                  → Логирование предупреждения
                  → Продолжение конвейера
```

## Оптимизации производительности

### Управление памятью

1. **Zero-Copy буферы**: Netty прямой ByteBuf → память GPU
2. **Подсчет ссылок**: Автоматический жизненный цикл буфера
3. **Пулированные аллокаторы**: Повторное использование буферов, минимизация GC
4. **Хранение вне кучи**: Изображения хранятся вне Java heap

### Конкурентность

1. **Виртуальные потоки**: Project Loom для блокирующего I/O
2. **Параллельные потоки**: Распараллеливание CPU обработки
3. **Lock-Free структуры**: Сбор метрик
4. **Реактивные планировщики**: Оптимальный размер пула потоков

### Настройка GC

1. **ZGC**: <1мс паузы
2. **Generational ZGC**: Лучшая пропускная способность
3. **Pre-touch память**: Избежание пауз выделения
4. **NUMA осведомленность**: Оптимизация локальности памяти

### Флаги JVM

```bash
-XX:+UseZGC                    # GC с низкой задержкой
-XX:+ZGenerational             # Generational ZGC
-XX:MaxGCPauseMillis=1         # Целевые паузы 1мс
-XX:+UnlockExperimentalVMOptions
-XX:+UseNUMA                   # NUMA оптимизация
-XX:+AlwaysPreTouch            # Предварительное выделение памяти
--enable-preview               # Vector API
--add-modules jdk.incubator.vector
```

## Масштабируемость

### Горизонтальное масштабирование

- Несколько экземпляров могут обрабатывать разные источники данных
- Общие метрики через внешнее хранилище (Redis и т.д.)
- Балансировка нагрузки между GPU узлами

### Вертикальное масштабирование

- Поддержка нескольких GPU (CUDA потоки)
- Масштабирование ядер CPU (параллельная обработка)
- Масштабирование памяти (большие буферы)

## Соображения безопасности

1. **HTTPS**: Все загрузки через защищенные соединения
2. **Валидация входных данных**: Проверка формата изображения
3. **Ограничения ресурсов**: Лимиты пула соединений
4. **Изоляция ошибок**: Сбои не приводят к краху системы

## Мониторинг

### Встроенные метрики

- Количество кадров
- Задержка (min/avg/max/p95/p99)
- Пропускная способность (fps)
- Использование памяти
- Утилизация GPU

### Внешний мониторинг

- JFR (Java Flight Recorder)
- Экспорт метрик JMX
- Агрегация логов (Logback)
- Профилирование производительности (JMH)

## Будущие улучшения

1. **Поддержка нескольких GPU**: Распределение обработки между GPU
2. **Распределенная обработка**: Кластерный режим с координацией
3. **Интеграция ML**: Модели предсказания солнечных вспышек
4. **WebSocket API**: Потоковая передача данных в реальном времени
5. **Облачное развертывание**: Оркестрация Kubernetes
